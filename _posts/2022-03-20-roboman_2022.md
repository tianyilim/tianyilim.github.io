---
layout: post
title: Robotic Manipulation Coursework 2022
date:   2022-03-20 00:00:00 +0000
categories: Portfolio
permalink: /portfolio/roboman_2022
---

This coursework was done as part of the Robotic Manipulation module in Imperial College, taught by [Dr Ad Spiers](https://www.linkedin.com/in/ad-spiers-37228027/).

I did it with my groupmates [Alexander Pondaven](https://github.com/alexpondaven) and [Peter (Shuanghua) Liu](https://github.com/shl2019).

The coursework involved use of the ROBOTIS [Dynamixel OpenManipulator-X](https://emanual.robotis.com/docs/en/platform/openmanipulator_x/overview/) 4DOF Robot Arm. The robots were programmed in MATLAB.

Our summary video is here:

<iframe width="560" height="315" src="https://www.youtube.com/embed/YnikLz3zWbM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Do look through our [report](https://github.com/alexpondaven/RoboMan/blob/main/RM%20Report%20-%20BOB.pdf) and [GitHub repo](https://github.com/alexpondaven/RoboMan).

## 1. Forward Kinematics

The Denavitâ€“Hartenberg (DH) parameters were used to model the forward kinematics (FK) of the robot. This is a convention that allows the transformation between the different coordinate frames that make up the robot to be defined.

In this case, as with most robotics applications (including ROS), the "right-hand" convention is followed, where coordinate frames look like this. Furthermore, by convention, $$x$$ is coloured red, $$y$$ green, and $$z$$ blue.
<p align="left"> <img width="250" src="../assets/RoboMan/rh_rule.png"> </p>

DH tables are comprised of the 4 DH parameters:
- $$d$$: offset along previous $$z$$ to the common normal.
- $$\theta$$: angle about previous $$z$$, from old $$x$$ to new $$x$$.
- $$a$$: length of the common normal, not to be confused with $$\alpha$$. Assuming a revolute joint, this is the radius about previous $$z$$.
- $$\alpha$$: angle about common normal, from old $$z$$ axis to new $$z$$ axis.

A DH table was derived: 

<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0pky">Link Number $${i}$$</th>
    <th class="tg-0pky">$$\alpha_{i-1}$$</th>
    <th class="tg-0pky">$$a_{i-1}$$</th>
    <th class="tg-0pky">$$d_i$$</th>
    <th class="tg-0pky">$$\theta_i$$</th>
    <th class="tg-0pky">Remarks</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">World Frame</td>
  </tr>
  <tr>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">34</td>
    <td class="tg-0pky">$$\theta_1$$</td>
    <td class="tg-0pky">Base of first servo</td>
  </tr>
  <tr>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">$$\pi/2$$</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">$$\pi/2$$</td>
    <td class="tg-0pky">Intermediate Frame</td>
  </tr>
  <tr>
    <td class="tg-0pky">3</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">43</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">$$\theta_2$$</td>
    <td class="tg-0pky">Base of second servo</td>
  </tr>
  <tr>
    <td class="tg-0pky">4</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">128</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">$$-\pi/2$$</td>
    <td class="tg-0pky">Elbow between servos</td>
  </tr>
  <tr>
    <td class="tg-0pky">5</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">24</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">$$\theta_3$$</td>
    <td class="tg-0pky">Base of third servo</td>
  </tr>
  <tr>
    <td class="tg-0pky">6</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">124</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">$$\theta_4$$</td>
    <td class="tg-0pky">Base of fourth servo</td>
  </tr>
  <tr>
    <td class="tg-0pky">7</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">126</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">0</td>
    <td class="tg-0pky">End effector</td>
  </tr>
</tbody>
</table>

A visualization of these frames is here.
<p align="left"> <img width="400" src="../assets/RoboMan/roboT1coordassign.PNG"> </p>

This allowed the robot to be simulated graphically in a MATLAB plot (using the `plot3` function). As per the frame convention, the long red, green, and blue lines are the $$x$$, $$y$$ and $$z$$ axes of the world. Robot links are modelled as thick black lines.

<p align="left"> <img width="400" src="../assets/RoboMan/roboT1bframes.PNG"> </p>

## 2. Inverse Kinematics

Inverse Kinematics (IK) are needed to create a transform from *task space* - the pose of the robot's end effector - to *joint space* - the angles at each robot's joint.

Look at the report for details on the derivation of the IK for this 4-DOF arm.

At first glance, a 4-DOF arm is difficult to obtain solutions for. The system is overdeterimined and there seem to be many possible configurations for a given desired end effector position. However, by also specifying the value of $$\theta_4$$ (the orientation of the 4th servo), the system returns to a 3-DOF system, which is easily broken down and solvable.

In a way, most higher-dimensional IK problems (4,5,6-DOF) should be solvable as such, by specifying the end effector's position **and** orientation, to obtain all joint values.

7-DOF systems are completely overdetermined, and that's why it's a lot harder to program for them. Here's hoping I'd have the chance to program one, one day.

## 3. Cube Manipulation

The next task that the team had to complete was 

## 4. Whiteboard Manipulation


## 5. Custom Task